#!/bin/bash
#PBS -l select=1:ncpus=4:mem=24gb:ngpus=1
#PBS -l walltime=01:00:00
#PBS -N ablation_test_robust
#PBS -o ablation_test_robust.out
#PBS -e ablation_test_robust.err

# EVEREST Ablation Study - Robust Single Experiment Test
# Addresses libstdc++ compatibility issues without modifying environment

set -e  # Exit on any error

# Function to log with timestamp
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

log "=== EVEREST Ablation Study - Robust Single Experiment Test ==="
log "Job ID: ${PBS_JOBID}"
log "Node: $(hostname)"

# Load system modules for compatibility
log "Loading system modules..."
module load gcc/9.3.0 2>/dev/null || log "GCC module not available"
module load cuda/11.8 2>/dev/null || log "CUDA module not available"

# Initialize conda
log "Initializing conda..."
source ~/miniforge3/etc/profile.d/conda.sh

# Change to submission directory
log "Changing to submission directory..."
cd $PBS_O_WORKDIR

log "Working directory: $(pwd)"

# Activate conda environment
log "Activating conda environment..."
conda activate everest_env

log "Conda environment: $CONDA_DEFAULT_ENV"

# Set environment variables for library compatibility
export LD_LIBRARY_PATH="$CONDA_PREFIX/lib:$LD_LIBRARY_PATH"
export CUDA_VISIBLE_DEVICES=$CUDA_VISIBLE_DEVICES
export PYTHONPATH=$PBS_O_WORKDIR:$PYTHONPATH

log "GPU device: $CUDA_VISIBLE_DEVICES"
log "Python executable: $(which python)"
log "Python version: $(python --version)"
log "LD_LIBRARY_PATH: $LD_LIBRARY_PATH"

# Test basic imports first
log "Testing basic imports..."
python -c "
import sys
print('Python path:', sys.path[:3])

try:
    import numpy as np
    print(f'✅ NumPy: {np.__version__}')
except Exception as e:
    print(f'❌ NumPy failed: {e}')
    sys.exit(1)

try:
    import torch
    print(f'✅ PyTorch: {torch.__version__}')
    if torch.cuda.is_available():
        print(f'✅ CUDA available: {torch.cuda.get_device_name(0)}')
    else:
        print('⚠️ CUDA not available')
except Exception as e:
    print(f'❌ PyTorch failed: {e}')
    sys.exit(1)
"

# Test pandas import with graceful handling
log "Testing pandas import..."
python -c "
import sys
try:
    import pandas as pd
    print(f'✅ Pandas: {pd.__version__}')
except ImportError as e:
    if 'GLIBCXX' in str(e):
        print('⚠️ Pandas has libstdc++ compatibility issue - will continue without pandas')
        print('This is expected and the ablation study can run without pandas')
    else:
        print(f'⚠️ Pandas import issue: {e}')
        print('Continuing without pandas...')
except Exception as e:
    print(f'⚠️ Pandas failed: {e}')
    print('Continuing without pandas...')
"

# Test ablation imports
log "Testing ablation imports..."
python -c "
import sys
import os
sys.path.insert(0, os.getcwd())

try:
    # Test individual components
    from models.solarknowledge_ret_plus import RETPlusWrapper
    print('✅ RETPlusWrapper imported')
    
    from models.ablation.config import OPTIMAL_HYPERPARAMS
    print('✅ Ablation config imported')
    
    print('✅ All ablation imports successful')
except Exception as e:
    print(f'❌ Ablation import failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"

# Test data loading with minimal dependencies
log "Testing data availability..."
python -c "
import sys
import os
import numpy as np
sys.path.insert(0, os.getcwd())

try:
    # Try to load data
    from models.utils import get_training_data, get_testing_data
    X_train, y_train = get_training_data('72', 'M5')
    X_test, y_test = get_testing_data('72', 'M5')
    print(f'✅ Data loaded: {len(X_train)} train, {len(X_test)} test samples')
except Exception as e:
    print(f'❌ Data loading failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"

# Run a minimal ablation test
log "Running minimal ablation test..."
python -c "
import sys
import os
import torch
import numpy as np
sys.path.insert(0, os.getcwd())

try:
    # Import and test basic functionality
    from models.ablation.trainer import AblationTrainer
    
    # Create a minimal trainer instance
    trainer = AblationTrainer('full_model', 0)
    print('✅ Trainer created successfully')
    
    # Test model creation
    model = trainer.create_model()
    print('✅ Model created successfully')
    
    # Test basic forward pass
    test_input = torch.randn(1, 10, 9).to(next(model.model.parameters()).device)
    with torch.no_grad():
        output = model.model(test_input)
    print('✅ Forward pass successful')
    
    print('✅ All tests passed - ready for full training')
    
except Exception as e:
    print(f'❌ Ablation test failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"

# Test a very short training run (1 epoch)
log "Testing short training run..."
python -c "
import sys
import os
import torch
import numpy as np
sys.path.insert(0, os.getcwd())

try:
    from models.ablation.trainer import AblationTrainer
    
    # Create trainer and run 1 epoch
    trainer = AblationTrainer('full_model', 0)
    
    # Load minimal data
    from models.utils import get_training_data
    X_train, y_train = get_training_data('72', 'M5')
    
    # Take only first 100 samples for quick test
    X_train = X_train[:100]
    y_train = y_train[:100]
    
    print(f'Running 1-epoch test with {len(X_train)} samples...')
    
    # Run very short training
    trainer.train(X_train, y_train, epochs=1, batch_size=32)
    
    print('✅ Short training test completed successfully')
    
except Exception as e:
    print(f'❌ Training test failed: {e}')
    import traceback
    traceback.print_exc()
    sys.exit(1)
"

log "Robust test completed successfully!" 